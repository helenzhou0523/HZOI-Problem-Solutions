题目描述(Porblem Description)


    德克萨斯淳朴的民众们这个夏天正在遭受巨大的热浪！他们的德克萨斯长角牛吃起来不错，可是他们并不是很擅长生产复函奶油的乳制品。
    Farmer John此时以先天下之忧而忧，后天下之乐而乐的精神，身先士卒地承担起向德克萨斯运送大量营养冰凉的牛奶的重任，以减轻德克萨斯人忍受酷暑的痛苦。 
    Farmer John已经研究过可以把牛奶从威斯康辛运送到德克萨斯州的路线。这些路线包括起点和终点在内一共经过T（1 <= T <= 2500）个城镇，标号为1到T。
    除了起点和终点外的每个城镇由两条双向道路连向其他城镇。每条道路有一个通过费用（包括油费，过路费等）。 
    给定一个地图，包含C（1 <= C <= 6200）条直接连接2个城镇的道路。每条道路由道路的起点Rs、终点Re（1 <= Rs <=T; 1 <= Re <= T）和
    花费Ci（1 <= Ci <= 1000）组成。求从起始的城镇Ts（1 <= Ts <= T）到终点城镇Te（1 <= Te <= T）最小的总费用。 
    
    (Farmer John wants to design routes to deliver milk from Wisconsin to Texas. These routes pass T（1 <= T <= 2500) towns including 
    start and end point. Except start and end, each town is connected to others with two roads with two opposite directions. 
    John needs to pay for a pass fee when go through each road. Given a map including C（1 <= C <= 6200）roads which connects two towns. 
    Every road consists of the start Rs, end Re(Re（1 <= Rs <=T; 1 <= Re <= T）and fee Ci（1 <= Ci <= 1000）. Please write a 
    program to calculate the minimium total fee to travel from start town Ts（1 <= Ts <= T）to end town Te（1 <= Te <= T）)


输入格式(Input format)


第1行：4个由空格隔开的整数：T, C, Ts, Te； 
(Line 1: four integers separated by space: T, C, Ts, Te;)

第2到C+1行：第i+1行描述第i条路，有3个由空格隔开的整数，Rs, Re和Ci。 
(Line 2-C+1: line i+1 describes the road i with three integers separated by space:Rs, Re and Ci)

输出(Output)

一个单独的整数，表示从Ts到Te的最小总费用。数据保证至少存在一条道路。
(a single integer representing the minimium total fee. The data promises there is at least one road existing )

样例输入(Sample output)

7 11 5 4
 2 4 2
 1 4 3
 7 2 2
 3 4 3
 5 7 5
 7 3 3
 6 1 1
 6 3 4
 2 4 3
 5 6 3
 7 2 1

样例输出(Sample output)

7


#include<iostream>
#include<cstring>
#include<queue>
using namespace std;
int st,e,t,c,a[2600][2600],disc[6300];
bool flag[2600]={0};
void cini();
void spaf(int);
int main()
{
	cini();
	return 0;
} 
void cini()
{
	cin>>t>>c>>st>>e;
	for(int i=1;i<=c;++i)
	{
		int x,y,z;
		cin>>x>>y>>z;
		a[x][y]=a[y][x]=z; 
	}
	spaf(st);
}
void spaf(int x)
{
	memset(disc,0x7f,sizeof(disc));
	queue<int> q;
	disc[x]=0;
	flag[x]=1;
	q.push(x);
	while(!q.empty())
	{
		int k=q.front();
		for(int i=1;i<=t;++i)
		{
			if(a[k][i]>0 &&disc[i]>disc[k]+a[k][i])
			{
				disc[i]=disc[k]+a[k][i];
				if(flag[i]==0)
				{
					flag[i]=1;
					q.push(i);
				}
			}
		}
		flag[q.front()]=0;
		q.pop();
	}
	//for(int i=1;i<=t;++i)
//	cout<<disc[i]<<' ';
	cout<<disc[e]<<endl;
}
