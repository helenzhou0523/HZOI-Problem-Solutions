Enter file contents here22212:过河卒分数: 10

时间限制：1 秒

内存限制：128 兆

特殊判题： 否

提交：121

解决： 49

题目描述

如图，A 点有一个过河卒，需要走到目标 B 点。卒行走规则：可以向下、或者向右。同时在棋盘上的任一点有一个对方的马（如上图的C点），该马所在的点和所有跳跃一步可达的点称为对方马的控制点。例如上图 C 点上的马可以控制 9 个点（图中的P1，P2 … P8 和 C）。卒不能通过对方马的控制点。

棋盘用坐标表示，A 点（0，0）、B 点（n,m）(n,m 为不超过 20 的整数，并由键盘输入)，同样马的位置坐标是需要给出的（约定: C<>A，同时C<>B）。现在要求你计算出卒从 A 点能够到达 B 点的路径的条数。

输入格式

B点的坐标（n,m）以及对方马的坐标（X,Y）{不用判错}

输出

一个整数（路径的条数）。

样例输入

6 6 3 2

样例输出

17



#include<iostream>
#include<cstring>
#include<queue>
using namespace std;

long long n,m,x,y,f[1010][1010],dx[10]={-2,-1,1,2,-2,-1,2,1},dy[10]={-1,-2,-2,-1,1,2,1,2};
bool flag[1010][1010]={0};

void cini();
int main()
{
	cini();
	
	for(int i=0;i<=n;++i)
	{
		for(int j=0;j<=m;++j)
		{
			if(flag[i][j]==0)
			{
				if(i-1>=0 && j-1>=0)
				f[i][j]=f[i-1][j]+f[i][j-1];
				if(i-1<0 && j-1>=0)
				f[i][j]=f[i][j-1];
				if(j-1<0 && i-1>=0)
				f[i][j]=f[i-1][j];
				//fl[jag[i][j]=1;
			}
			//else f[i][j]=0;
			//cout<<f[i][j]<<' ';
		}
		
	}	/*cout<<endl;
		for(int i=0;i<=8;++i)
		{
			for(int j=0;j<=8;++j)
			cout<<f[i][j]<<' '; 
			cout<<endl;
		}	*/
	cout<<f[n][m]<<endl;
	return 0;
}
void cini()
{
	cin>>n>>m>>x>>y;
	flag[x][y]=1;
	for(long long i=0;i<8;++i)
	flag[dx[i]+x][dy[i]+y]=1;
	for(long long i=0;i<=8;++i)
	f[i][0]=f[0][i]=1;
	for(int i=0;i<=n;++i)
	{
		if(flag[i][0]==1)
		{
			for(int j=i;j<=8;++j)
			f[j][0]=0;
		}		
	}
	for(long long i=1;i<=m;++i)
	{
		if(flag[0][i]==1)
		{
			for(int j=i;j<=8;++j)
			f[0][j]=0;
		}
	}
	/*for(int i=0;i<=8;++i)
		{
				for(int j=0;j<=8;++j)
			{
				cout<<flag[i][j]<<' ';
			}
			cout<<endl;
		}
		cout<<endl;*/
}
